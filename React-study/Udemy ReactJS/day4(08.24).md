##### Composition(컴포지션) and childern

- ExpenseItem.js
```js
import Card from "./Card";

import ExpenseDate from "./ExpenseDate";

import "./ExpenseItem.css";

  

function ExpenseItem(props) {

  return (

    // React에서 class는 예약어이기 때문에 속성값을 줄 때는 className을 사용

    <Card className="expense-item">

      <ExpenseDate date={props.date} />

      <div className="expense-item__description">

        <h2>{props.title}</h2>

        <div className="expense-item__price">${props.amount}</div>

      </div>

    </Card>

  );

  // JSX의 규칙 : JSX 코드 조각마다 반드시 하나의 Root element를 가져야한다.

  // 반환할 때는 하나의 요소여야하기 때문에 div태그로 묶었다.

}

  

export default ExpenseItem;
```

- Card.js -> wrapper components
```js
import "./Card.css";

  

function Card(props) {

  

  const classes = 'card ' + props.className; //컴포넌트 바깥에서 className으로 받는 속성값들이 문자열로 추가

  

  return <div className={classes}>{props.children}</div>;

  

}

export default Card;

```

커스텀 컴포넌트를 래퍼로 사용하기 위해 props.children을 사용한다. 
이 경우, `<Card>` 안에 있는 컨텐츠들은 props.children에서 사용 가능


![[Pasted image 20220824133750.png]]

상수 객체인 classes에게 브레이킹 포인트를 맞추고 디버깅을 해보면, Card 컴포넌트가 내려받은 props의 className이 ExpensItem 컴포넌트의 expense-item인것을 확인할 수 있다. 

![[Pasted image 20220824133915.png]]



---
##### JSX



---
Section 4 : State

Handling Events


이벤트 리스너를 추가하는 방식은 명령형 방식이다, react에서는 jsx요소로 이벤트 요소를 추가한다. 
on으로 시작하는 props를 사용한다.

React는 모든 기본 이벤트를 on으로 시작하는 props를 expose한다. 

모든 이벤트 핸들러 props는 값으로 function이 필요하고, onClick과 같은 함수들은 이벤트가 발생되었을 때 실행된다. 

```js
import React from 'react'

import Card from "../UI/Card";

import ExpenseDate from "./ExpenseDate";

import "./ExpenseItem.css";

  

const ExpenseItem = (props) => {

  

  const clickHandler = () => {

    console.log('Clicked!!')

  }

  
  
  

  return (

    // React에서 class는 예약어이기 때문에 속성값을 줄 때는 className을 사용

    <Card className="expense-item">

      <ExpenseDate date={props.date} />

      <div className="expense-item__description">

        <h2>{props.title}</h2>

        <div className="expense-item__price">${props.amount}</div>

      </div>

      <button onClick={clickHandler}>Change Title</button>
  
    </Card>

  );

  // JSX의 규칙 : JSX 코드 조각마다 반드시 하나의 Root element를 가져야한다.

  // 반환할 때는 하나의 요소여야하기 때문에 div태그로 묶었다.

}

  

export default ExpenseItem;
```


> 주의!! 만약 여기에 ()를 추가했다면 clickHandler 함수는 클릭 했을 때가 아닌, 코드가 분석될 때 실행되어버린다.
  

![[Pasted image 20220824155759.png]]

일반적으로 JSX 코드가 반환될 때 코드 라인이 분석이 된다.


- 리액트가 JSX 코드를 어떻게 전달하고, 어떻게 검토해서, 어떻게 화면에 불러오는가
	1. 리액트는 JSX에서 마주치는 컴포넌트 함수들을 계속해서 호출한다.
	2. 호출할 코드가 더이상 남아있지 않을 때까지 컴포넌트의 JSX코드를 통과한다.
	3. 전반적인 결과를 다시 evaluate하고 DOM 명령어로 translate해서 화면에 보여진다.( = 렌더링)

리액트는 어플이 처음 렌더링 되었을 때 모든 과정을 실행하고 그 후에는 끝이다. 
=> IF, 화면에 보이는 것을 업데이트하고 싶다면 **state**를 사용한다.

리액트에게 어떤 것이 변경되었고, 특정 component가 re-evaluate되야한다고 알리기 위해 도입한 것이 state

---
##### State



